# 2025.08.24
-------------

starting this so I have a running commentary on my changes and funny things I notice happening
in my code

today's discovery: the first version of the init_diag_value_matrix was messing with the execution
of the pvr_set_bg_color() function. originally, the function worked properly with the init_identity() matrix
function. at first i thought it was simply an emulator bug but it seemed suspicious that a single function 
would cause display corruption like that. additionally the bfont_draw_str_vram_fmt function still works
properly and displays the memory address of the dcm_file_hdr.version struct element consistently, so 
i ruled out the emulator.

i've since transposed the header and inline functions to C++ alongside main and am now reworking the diagonal
matrix loading function

changes:
	main.c   -> main.cpp
	matrix.h -> matrix.hpp
	removed contents of init_diag_value_matrix
	transposed init_identity() to C++ style inline asm

results:
	program still compiles and displays screen background color correctly

tbd: 
	complete diagonal value matrix with correct formatting and instructions


# 2025.8.24 - 21:52
-------------------

Great!! The matrix is fixed properly (thanks again Falco for the advice, switching to C++ and
figuring out constraints has really helped a lot).

notes: the ending of the 'init_identity' matrix already switches to the front bank, so
calling it at the beginning of the init_diag_value_matrix was causing issues. additionally we
are now ignoring the approach of calling the init_identity matrix function since it was a little
naive. as Falco explained to me, we cannot pass floating point values directly into the back bank
via inline asm, since the CPU doesn't really know how to do so - they must be juggled through FPUL
which is a system register that allows for transfer between floating point and general purpose regs.
the FLOAT instruction will be massively helpful here (note to self: read up more on execution cycles)

changes:
	removed init_identity() call before inline asm
	basically reconstructed identity matrix from scratch
	used fmov.s to copy the addresses of function arguments (x, y, z, w)

results:
	program compiles successfully with no warnings
	pvr_set_bg_color also functions as expected

tbd:
	finish rotation matrices (x, y, z).

# 2025.8.25
-----------

Okay, now we're running into some interesting issues and I'm breaking out the objdump because I want to 
know what's going on. Here's the problem:

Since rewriting the diagonal matrix initialization from scratch (and fixing the incorrect syntax),
I wanted to test whether I could actually see any of the functions running by calling them in main.
So far, that has been educational.

The problem we're now dealing with: the graphics bug is back; and I am not sure what's going on. 
Earlier, when I had a matrix function that involved inline asm, calling another function, and 
clobbering registers/loading registers, there was some graphics corruption with PVR and the 
background color I set. The BIOS font print log function that I call outside the pvr_scene_begin()
function still works fine and the memory address of the struct element is still consistently the same
so having this graphics bug come back is puzzling me. So far I've tried a few things:

> removing the "m" constraints
> adding clobbers (fr0-fr15, including memory)
> moving fschg between the 1st fldi0 and 3rd
> changing the registers I use for the DR copies (DR2, DR6, DR8)
> using inline instead of __inline__

Here's what pvr_set_bg_color() is doing:

  pvr_set_bg_color(0.1f, 0.0f, 0.4f);
8c010254:	21 d1       	mov.l	8c0102dc <_main+0xb0>,r1	! 8c018a14 <_pvr_set_bg_color>
8c010256:	22 c7       	mova	8c0102e0 <_main+0xb4>,r0
8c010258:	09 f6       	fmov	@r0+,fr6
8c01025a:	08 f4       	fmov	@r0,fr4
8c01025c:	0b 41       	jsr	@r1
8c01025e:	8d f5       	fldi0	fr5

}

It seems like there's some register clashing going on seeing as fr5 is loaded with a 0 at the very end of pvr_set_bg_color()
and from the objdump, it seems like there are memory issues/register clashing.

> update 00:40

I FIXED IT. JUST THE COMPILER FLAGS IN THE MAKEFILE. TURNS OUT THAT HAVING

-ml -m4-single-only -ffast-math -mfsrra -mfsca 

KIND OF FUCKS THINGS UP.

I wonder why though? Those are the flags taken directly from the Godbolt compiler explorer SH GCC 4.94... oh, maybe a newer version would
do something different...

Time for more testing. In any case, here's the updated pvr_set_bg_color:

  pvr_set_bg_color(0.1f, 0.0f, 0.4f);
8c01024c:	20 d1       	mov.l	8c0102d0 <_main+0xa4>,r1	! 8c018a04 <_pvr_set_bg_color>
8c01024e:	21 c7       	mova	8c0102d4 <_main+0xa8>,r0
8c010250:	09 f7       	fmov	@r0+,fr7
8c010252:	09 f5       	fmov	@r0+,fr5
8c010254:	0b 41       	jsr	@r1
8c010256:	8d f4       	fldi0	fr4

}

and the updated __inline__ void init_scale_matrix right before the main loop:

__inline__ void init_scale_matrix(float x, float y, float z){
		
	init_diag_value_matrix(x, y, z, 1.0f);
8c010258:	20 d3       	mov.l	8c0102dc <_main+0xb0>,r3	! 404ccccd
8c01025a:	f3 61       	mov	r15,r1
8c01025c:	20 d7       	mov.l	8c0102e0 <_main+0xb4>,r7	! 40466666
8c01025e:	04 71       	add	#4,r1
8c010260:	f3 62       	mov	r15,r2
8c010262:	08 72       	add	#8,r2
8c010264:	32 21       	mov.l	r3,@r1
8c010266:	32 22       	mov.l	r3,@r2
8c010268:	f3 63       	mov	r15,r3
8c01026a:	0c 73       	add	#12,r3
8c01026c:	9d f1       	fldi1	fr1
8c01026e:	72 23       	mov.l	r7,@r3
8c010270:	f3 67       	mov	r15,r7
8c010272:	10 77       	add	#16,r7
8c010274:	1a f7       	fmov	fr1,@r7
  asm(R"(  
8c010276:	fd fb       	frchg	
8c010278:	8d f1       	fldi0	fr1
8c01027a:	8d f2       	fldi0	fr2
8c01027c:	8d f3       	fldi0	fr3
8c01027e:	fd f3       	fschg	
8c010280:	2c f6       	fmov	fr2,fr6
8c010282:	2c f8       	fmov	fr2,fr8
8c010284:	8d fb       	fldi0	fr11
8c010286:	2c fc       	fmov	fr2,fr12
8c010288:	fd f3       	fschg	
8c01028a:	8d fe       	fldi0	fr14
8c01028c:	18 f0       	fmov	@r1,fr0
8c01028e:	28 f5       	fmov	@r2,fr5
8c010290:	38 fa       	fmov	@r3,fr10
8c010292:	78 ff       	fmov	@r7,fr15
8c010294:	fd fb       	frchg	
8c010296:	13 dd       	mov.l	8c0102e4 <_main+0xb8>,r13	! 8c010da0 <_bfont_draw_str_vram_fmt>
8c010298:	f3 6e       	mov	r15,r14
8c01029a:	13 dc       	mov.l	8c0102e8 <_main+0xbc>,r12	! 8c019030 <_pvr_scene_begin>
8c01029c:	13 7e       	add	#19,r14
8c01029e:	13 db       	mov.l	8c0102ec <_main+0xc0>,r11	! 8c019420 <_pvr_list_begin>
8c0102a0:	13 da       	mov.l	8c0102f0 <_main+0xc4>,r10	! 8c0190d0 <_pvr_list_finish>
8c0102a2:	14 d9       	mov.l	8c0102f4 <_main+0xc8>,r9	! 8c0194dc <_pvr_scene_finish>
  init_scale_matrix(3.2f, 3.2f, 3.1f);  

That's all I'm gonna do for tonight, I think.

# 2025.8.26
-----------

Angles and trig stuff I'm messing around with just for the sake of exploring fixed point math:

Everything revolves around FSCA; SH-4 instruction that performs cos and sin in one op and stores them in a double
precision floating point register. However it only takes in integers in the range 0-32767, or a 16-bit int. 

I mentioned before that I want to explore using tau instead of pi for my rotations, since tau describes 2pi or 
1 full rotation of a circle. Mathematically speaking I think that just looks nicer and is easier for my brain
to deal with. 

so we use

#define tau 32767

which is fine; technically, it should be 32768 for more accuracy but for FSCA and hacky reasons we wrap that last bit
to 0 by going

&ing tau against itself 

Dreamcast vector math hints page https://yam.20to4.net/dreamcast/hints/index.html#Vector Math Instructions
suggests redefining angle representations so that pi = 16384

I'm gonna try this:

#include <stdio.h>
#include <math.h>
#include <stdint.h>

#define FSCA_MAX 32767

int main(){

	int deg;
	double total_error = 0;
	double max_error   = 0;
	int max_error_deg  = 0;

    for(deg = 0; deg <= 360; deg++){

	double exact = (deg * FSCA_MAX) / 360.0;

	int32_t approx = (deg * 23301 + 128) >> 8; 

	double error = fabs(approx - exact);
	total_error += error;

	if(error > max_error){
		max_error = error;
		max_error_deg = deg;
	}
    }


	double avg_error = total_error / 361; 

	printf("testing deg_to_fsca approximation\n");
	printf("max error: %f at %d degrees\n", max_error, max_error_deg);
	printf("average error: %f\n", avg_error);

	return 0;
}

Results without rounding:

	max_error: 0.991667 at 51 degrees
	avg_error: 0.481025

 
Results with rounding:
	max_error: 0.525000 at 333 degrees
	avg_error: 0.249692

> update 15:28

Wow, it actually works. Called it in main, no errors no warnings, 
objdump looks normal as well. I'm genuinely shocked. 

basically we're looking at 

inline uint16 deg2fsca(uint16 deg){
	deg = deg % 360;

	if(deg < 0) deg += 360;

	uint32 deg_32 = (uint32)deg;

	uint32 angle = (deg_32 * 23301 + 128) >> 8;

	return angle & tau;
	deg %  360;

}

> update 16:29

wrote out 2 versions of the routine: fast and safe

fast eschews the modulo in favor of simple add/sub checking

	if(deg >= 360) -= 360;
	if(deg < 0) += 360;

whereas the safe version still has the modulo. Genuinely have 
no idea how effective this is gonna be until I actually put 
together the rotation matrices and start shoving things at the
PVR to show them on screen, but at least that's outta the way. 

changes:
	added fast and safe versions of deg2fsca

results:
	program compiles as normal, no errors/warnings


# 2025.8.27
-----------

Okay! New updates on the whole deg2fsca thing; turns out I was massively overthinking it. 
Which is good to know now rather than later. Helpful conversation on the discord with
pcercuei and falco about the risk of trying to outsmart the compiler - GCC's good at this
stuff, but less so back-bank XMTRX and vectorization stuff which almost
always benefits from handwritten asm. Gonna try and rewrite and profile against
Compiler Explorer and get the results back. 

Gonna keep all the above up for historical reasons but probably commented out - 
the functions themselves are gonna be rewritten

Now we're trying

inline int16 fast_deg2fsca(int16 deg){
	int32 angle = ((int32)deg * 65535 / 360) & 0xFFFF;
	return angle;
}

Still kind of wondering whether I should mask or not as a safety check
I'll just keep it there for now and move on to implementing rotation matrices


# 2025.8.28
-----------

So, I've ended up reworking the fast_deg2fsca function again based on stuff 
I read in the docs. since fsca basically takes in a 32-bit int and interprets
it as a 16.16 fixed point int, i've reworked the function to reflect the size.

changes:
	int16 in function fast_deg2fsca -> int32
	added normalization guard (deg % 360)
	wrote out rotation_matrix for z axis

results:
	errors: invalid operands for opcode. 
	

The logic here should be sound - I'm just banging my head against the constraints.
